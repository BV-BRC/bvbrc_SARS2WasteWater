#### before pushing to alpha fix sample level metadata (primers and dates) ###
#### before pushing production to uncomment multiqc for production ###

msg = "snakefile command recieved - FREYJA AND POST PROCESSING \n"
sys.stderr.write(msg)

# ruleorder: freyja_variants > freyja_demix > sample_freyja_vis
### Define wildcards ###
pe_zpd_samples = glob_wildcards("staging/pe_reads/{sample}_R{read_num}.fastq.gz").sample
pe_unzpd_samples = glob_wildcards("staging/pe_reads/{sample}_R{read_num}.fastq").sample
se_zpd_samples = glob_wildcards("staging/se_reads/{sample}.fastq.gz").sample
se_unzpd_samples = glob_wildcards("staging/se_reads/{sample}.fastq").sample
samples = pe_zpd_samples+ pe_unzpd_samples + se_zpd_samples + se_unzpd_samples

### Define functions for global handelers: Onstart, onsuccess and onerror ###
# Define the onstart handler
def onstart(samples):
    print(f"Starting workflow for {wildcards}")
# Define the onsuccess handler
def onsuccess(samples):
    print(f"Workflow completed successfully for {wildcards}")


# Define the onerror handler
def onerror(wildcards, input, output, error):
    msg = f"Error occurred for {wildcards} \n \
    Input: {input} \n \
    Output: {output} \n \
    Error: {error}"
    with open("JobFailed.txt", "w") as failed_samples:
        print(msg)
    pass

### Define global handlers ###
onstart: onstart
onsuccess: onsuccess
onerror: onerror
configfile: "config.json"
workflow_dir = config["workflow_dir"]
### freyja variant variables ###
minimum_base_quality_score_val = config["params"]["minimum_base_quality_score"]
### freyja demix command variables ###
barcodes_path = config["barcodes_path"]
curated_linages = config["curated_linages"]
eps_val = config["params"]["minimum_lineage_abundance"]
covcut_val = config["params"]["coverage_estimate"]
depthcutoff_val = config["params"]["minimum_coverage_depth"]
if config["params"]["confirmedonly"] == True:
    confirmed_only_status = "--confirmedonly"
else:
    confirmed_only_status = ""
### freyja aggregate variables ###
minimum_genome_coverage_val = config["params"]["minimum_genome_coverage"]
### freyja plot variables ###
agg_minimum_lineage_abundance_val = config["params"]["agg_minimum_lineage_abundance"]
### version long variables ###
primer_type = config["params"]["primers"]
primer_version = config["params"]["primer_version"]


# Define base rule all
rule_all_list = [
        expand("output/{sample}/{sample}_freyja_variants.tsv", sample=samples),
        expand("output/{sample}/{sample}_demixing_result.csv", sample=samples),
        expand("output/{sample}/{sample}_variant_plot.png", sample=samples),
        expand("output/summarized_variants.png", sample=samples),
        expand("output/version_log.txt"),
        expand("output/multiqc_report.html")
    ]

# If metadata.tsv is passed then make the time series plots
if os.path.exists(config["staging_sample_metadata_path"]):
    edited_sample_metadata_csv_path = config["staging_sample_metadata_path"]
    if config["params"]["timeseries_plot_interval"] != "0":
        rule_all_list.append("output/multisample_timeseries.png")
        timeseries_interval_val = config["params"]["timeseries_plot_interval"]
    else:
        timeseries_interval_val = ""
    print('making time series plots')
else:
    edited_sample_metadata_csv_path = ""
    timeseries_interval_val = ""
    msg = f"Sample metadata tsv file unavailable. Not producing time series plots"
    sys.stderr.write(msg)
    pass

## Add Multisample rules to rule all ##
if len(samples) != 1:
    rule_all_list.append("output/multisample_demix_results.tsv")
    rule_all_list.append("output/summarized_variants.png")
    rule_all_list.append("output/lineage_variants.png")
else:
    msg = f"Only one sample. Not producing multisample outputs"
    sys.stderr.write(msg)
    pass

rule all:
    input:
        rule_all_list

rule freyja_variants:
    input:
        ivar_bam_sorted = "output/{sample}/assembly/{sample}.sorted.bam",
        reference = "output/{sample}/assembly/reference_trimmed.fa",
        curated_linages_ = curated_linages
    params:
        eps = eps_val,
        freyja_analysis_dir = directory("output/{sample}"),
        minimum_base_quality_score = minimum_base_quality_score_val,
        tmp_dir = directory("./tmp/")
    output:
        variants = "output/{sample}/{sample}_freyja_variants.tsv",
        depth = "output/{sample}/{sample}_freyja.depths",
    shell:
        """
        mkdir -p {params.freyja_analysis_dir}

        freyja variants \
            {input.ivar_bam_sorted} \
            --minq {params.minimum_base_quality_score} \
            --variants {output.variants} \
            --depths {output.depth} \
            --ref {input.reference}
        """

rule freyja_demix:
    input:
        barcodes = barcodes_path,
        curated_linages_ = curated_linages,
        variants = "output/{sample}/{sample}_freyja_variants.tsv",
        depth = "output/{sample}/{sample}_freyja.depths",
    params:
        eps = eps_val,
        covcut = covcut_val,
        confirmedonly = confirmed_only_status,
        depthcutoff = depthcutoff_val,
        tmp_dir = directory("tmp/"),
        error_msg = "tmp/{sample}_demix_error.txt"
    output:
        freyja_file = "output/{sample}/{sample}_demixing_result.csv",
        tmp_freyja = "tmp/{sample}_demixing_result.csv"
    shell:
        """
        mkdir -p {params.tmp_dir}

        freyja demix \
            --eps {params.eps} \
            --barcodes {input.barcodes} \
            --meta {input.curated_linages_} \
            --covcut {params.covcut} \
            {params.confirmedonly} \
            --depthcutoff {params.depthcutoff} \
            {input.variants} \
            {input.depth} \
            --output {output.freyja_file} > {params.error_msg}

        cp {output.freyja_file} {output.tmp_freyja}
        """

rule sample_freyja_vis:
    input:
        # Freyja aggregate command expects a directory not the demixing results files themselves
        # adding the demxing results to help multi threading track the order
        freyja_file = "output/{sample}/{sample}_demixing_result.csv"
    params:
        freyja_dir = directory("output/{sample}/"),
        cl_agg_dir = directory("clean_up/single_aggs/{sample}"),
        single_aggregate = "output/{sample}/{sample}_aggregated_result.tsv",
        ext = "_demixing_result.csv",
        minimum_genome_coverage = minimum_genome_coverage_val,
        agg_minimum_lineage_abundance = agg_minimum_lineage_abundance_val,
        variant_plot_msg = "tmp/{sample}_sample_variant_plot_error.txt",
        lineage_plot_msg = "tmp/{sample}_sample_lineage_plot_error.txt"
    output:
        plot = "output/{sample}/{sample}_variant_plot.png",
        lineage_plot = "output/{sample}/{sample}_linage_plot.png",
        clean_single_aggregate = "clean_up/single_aggs/{sample}/{sample}_aggregated_result.tsv",
    shell:
        """
        freyja aggregate \
            {params.freyja_dir} \
            --ext {params.ext} \
            --output {params.single_aggregate}

        freyja plot \
            {params.single_aggregate} \
            --mincov {params.minimum_genome_coverage} \
            --thresh {params.agg_minimum_lineage_abundance} \
            --output {output.plot} > {params.variant_plot_msg}

        freyja plot \
            {params.single_aggregate} \
            --lineages \
            --mincov {params.minimum_genome_coverage} \
            --thresh {params.agg_minimum_lineage_abundance} \
            --output {output.lineage_plot} > {params.lineage_plot_msg}
        
        # the single aggregate file is redundant to the freyja file. Moving to clean up directory
        mkdir -p {params.cl_agg_dir}

        mv {params.single_aggregate} {output.clean_single_aggregate}
        """

rule set_aggregate_command:
    input:
        # Freyja aggregate command expects a directory not the files themselves
        # Using the tmp message file incase a sample files to stil populate even if some samples fail
        # Using set to ensure all files try to run demix. Then use any availble demix results.
        set_tmp_msg_file = set(expand("output/{sample}/{sample}_demixing_result.csv", sample=samples))
    params:
        # for snakemake the directory needs to end with "/"
        tmp_dir = directory("tmp/"),
        ext = "_demixing_result.csv",
    output:
        aggregated = "output/multisample_demix_results.tsv",
    shell:
        """
        freyja aggregate \
            {params.tmp_dir} \
            --ext {params.ext} \
            --output {output.aggregated}
        """
rule set_freyja_variant_vis:
    input:
        set_agg = "output/multisample_demix_results.tsv"
    params:
        # for snakemake the directory needs to end with "/"
        tmp_dir = directory("tmp/"),
        ext = "_demixing_result.csv",
        minimum_genome_coverage = minimum_genome_coverage_val,
        agg_minimum_lineage_abundance = agg_minimum_lineage_abundance_val
    output:
        summarized_plot = "output/summarized_variants.png",
    shell:
        """
        freyja plot \
            {input.set_agg} \
            --mincov {params.minimum_genome_coverage} \
            --thresh {params.agg_minimum_lineage_abundance} \
            --output {output.summarized_plot}
        """

rule set_freyja_lineage_vis:
    input:
        # Using the tmp message file incase a sample files to stil populate even if some samples fail
        # Using set to ensure all files try to run demix. Then use any availble demix results.
        aggregated = "output/multisample_demix_results.tsv"
    params:
        # for snakemake the directory needs to end with "/"
        tmp_dir = directory("tmp/"),
        ext = "_demixing_result.csv",
        minimum_genome_coverage = minimum_genome_coverage_val,
        agg_minimum_lineage_abundance = agg_minimum_lineage_abundance_val
    output:
        lineage_plot = "output/lineage_variants.png",
    shell:
        """

        freyja plot \
            {input.aggregated} \
            --lineages \
            --mincov {params.minimum_genome_coverage} \
            --thresh {params.agg_minimum_lineage_abundance} \
            --output {output.lineage_plot}
        """

rule time_series_plot:
    input:
        aggregated = "output/multisample_demix_results.tsv",
        metadata_tsv = edited_sample_metadata_csv_path
    params:
        #the directory needs to end with "/"
        tmp_dir = directory("tmp/"),
        ext = "_demixing_result.csv",
        minimum_genome_coverage = minimum_genome_coverage_val,
        agg_minimum_lineage_abundance = agg_minimum_lineage_abundance_val,
        timeseries_interval = timeseries_interval_val
    output:
        multisample_timeseries_plot = "output/multisample_timeseries.png"
    shell:
        """
        freyja plot {input.aggregated} \
            --times {input.metadata_tsv} \
            --interval {params.timeseries_interval} \
            --output {output.multisample_timeseries_plot}
        """

rule multiqc:
    input:
       multiqc_config = os.path.join(workflow_dir, "multiqc_config.yaml"),
    params:
        landing_dir = directory('output'),
        tmp_multiqc_dir = directory('output/multiqc_data')
    output:
        'output/multiqc_report.html',
        cl_multiqc_dir = directory("clean_up/multiqc_data")
    shell:
        """
        multiqc --version

        multiqc output/. \
            -c {input.multiqc_config} \
            -o {params.landing_dir} --fullnames \
            -f
        
        mkdir -p {output.cl_multiqc_dir}

        mv {params.tmp_multiqc_dir} {output.cl_multiqc_dir}
        """

rule write_out_versions:
    output: version_log = "output/version_log.txt"
    params:
        primer_tp = primer_type,
        primer_v = primer_version
    shell:
        """
        echo "The results may vary depending on the version of Freyja, \
        its dependences and the barcode file used. The barcode file is a \
        .tsv file that is used in lineage-determination defined by the UShER \
        global phylogenetic tree. We update the barcodes every two weeks.\n \
        Below are the versions of the tools used" >> {output.version_log}
        freyja --version >> {output.version_log}
        
        echo "Barcode version:" >> {output.version_log}
        
        echo usher --version >> {output.version_log}
        
        echo ivar version >> {output.version_log}
        
        echo "primer type: {params.primer_tp}" >> {output.version_log}
        
        echo "primer version: {params.primer_v}" >> {output.version_log}
        
        echo samtools version >> {output.version_log}
        """